/* tslint:disable */
/* eslint-disable */
/**
 * Limelight API
 * Limelight manages your theatre production process from auditions to bump out.
 *
 * The version of the OpenAPI document: 1.0.108
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Document,
  DocumentRepo,
  DocumentTag,
  DocumentVersion,
  Folder,
  PaginatedDocumentList,
  PaginatedDocumentRepoList,
  PaginatedDocumentTagList,
  PaginatedDocumentVersionList,
  PaginatedFolderList,
  PaginatedTagList,
  PatchedDocument,
  PatchedDocumentRepo,
  PatchedDocumentVersion,
  PatchedFolder,
  PatchedTag,
  Tag,
} from '../models/index';
import {
    DocumentFromJSON,
    DocumentToJSON,
    DocumentRepoFromJSON,
    DocumentRepoToJSON,
    DocumentTagFromJSON,
    DocumentTagToJSON,
    DocumentVersionFromJSON,
    DocumentVersionToJSON,
    FolderFromJSON,
    FolderToJSON,
    PaginatedDocumentListFromJSON,
    PaginatedDocumentListToJSON,
    PaginatedDocumentRepoListFromJSON,
    PaginatedDocumentRepoListToJSON,
    PaginatedDocumentTagListFromJSON,
    PaginatedDocumentTagListToJSON,
    PaginatedDocumentVersionListFromJSON,
    PaginatedDocumentVersionListToJSON,
    PaginatedFolderListFromJSON,
    PaginatedFolderListToJSON,
    PaginatedTagListFromJSON,
    PaginatedTagListToJSON,
    PatchedDocumentFromJSON,
    PatchedDocumentToJSON,
    PatchedDocumentRepoFromJSON,
    PatchedDocumentRepoToJSON,
    PatchedDocumentVersionFromJSON,
    PatchedDocumentVersionToJSON,
    PatchedFolderFromJSON,
    PatchedFolderToJSON,
    PatchedTagFromJSON,
    PatchedTagToJSON,
    TagFromJSON,
    TagToJSON,
} from '../models/index';

export interface DocumentsV1ReposCreateRequest {
    tenantRef: string;
    documentRepo: Omit<DocumentRepo, 'id'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

export interface DocumentsV1ReposDestroyRequest {
    id: number;
    tenantRef: string;
}

export interface DocumentsV1ReposDocumentsCreateRequest {
    repoId: string;
    tenantRef: string;
    document: Omit<Document, 'id'|'author_name'|'repo_name'|'folder_path'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'|'repo'>;
}

export interface DocumentsV1ReposDocumentsDestroyRequest {
    id: number;
    repoId: string;
    tenantRef: string;
}

export interface DocumentsV1ReposDocumentsListRequest {
    repoId: string;
    tenantRef: string;
    author?: number;
    folderId?: string;
    page?: number;
    pageSize?: number;
    production?: number;
    statusIexact?: string;
    titleIcontains?: string;
}

export interface DocumentsV1ReposDocumentsPartialUpdateRequest {
    id: number;
    repoId: string;
    tenantRef: string;
    patchedDocument?: Omit<PatchedDocument, 'id'|'author_name'|'repo_name'|'folder_path'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'|'repo'>;
}

export interface DocumentsV1ReposDocumentsRetrieveRequest {
    id: number;
    repoId: string;
    tenantRef: string;
}

export interface DocumentsV1ReposDocumentsTagsCreateRequest {
    documentId: string;
    repoId: string;
    tenantRef: string;
    documentTag?: Omit<DocumentTag, 'id'|'tag'|'document'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

export interface DocumentsV1ReposDocumentsTagsDestroyRequest {
    documentId: string;
    id: number;
    repoId: string;
    tenantRef: string;
}

export interface DocumentsV1ReposDocumentsTagsListRequest {
    documentId: string;
    repoId: string;
    tenantRef: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsV1ReposDocumentsTagsRetrieveRequest {
    documentId: string;
    id: number;
    repoId: string;
    tenantRef: string;
}

export interface DocumentsV1ReposDocumentsUpdateRequest {
    id: number;
    repoId: string;
    tenantRef: string;
    document: Omit<Document, 'id'|'author_name'|'repo_name'|'folder_path'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'|'repo'>;
}

export interface DocumentsV1ReposDocumentsVersionsCreateRequest {
    documentId: string;
    repoId: string;
    tenantRef: string;
    documentVersion: Omit<DocumentVersion, 'id'|'created_at'|'updated_at'|'archive_at'|'version'|'tenant'|'created_by'|'updated_by'|'document'>;
}

export interface DocumentsV1ReposDocumentsVersionsDestroyRequest {
    documentId: string;
    id: number;
    repoId: string;
    tenantRef: string;
}

export interface DocumentsV1ReposDocumentsVersionsListRequest {
    documentId: string;
    repoId: string;
    tenantRef: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsV1ReposDocumentsVersionsPartialUpdateRequest {
    documentId: string;
    id: number;
    repoId: string;
    tenantRef: string;
    patchedDocumentVersion?: Omit<PatchedDocumentVersion, 'id'|'created_at'|'updated_at'|'archive_at'|'version'|'tenant'|'created_by'|'updated_by'|'document'>;
}

export interface DocumentsV1ReposDocumentsVersionsRetrieveRequest {
    documentId: string;
    id: number;
    repoId: string;
    tenantRef: string;
}

export interface DocumentsV1ReposDocumentsVersionsUpdateRequest {
    documentId: string;
    id: number;
    repoId: string;
    tenantRef: string;
    documentVersion: Omit<DocumentVersion, 'id'|'created_at'|'updated_at'|'archive_at'|'version'|'tenant'|'created_by'|'updated_by'|'document'>;
}

export interface DocumentsV1ReposFoldersCreateRequest {
    repoId: string;
    tenantRef: string;
    folder: Omit<Folder, 'id'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

export interface DocumentsV1ReposFoldersDestroyRequest {
    id: number;
    repoId: string;
    tenantRef: string;
}

export interface DocumentsV1ReposFoldersListRequest {
    repoId: string;
    tenantRef: string;
    page?: number;
    pageSize?: number;
    parentFolderId?: string;
}

export interface DocumentsV1ReposFoldersPartialUpdateRequest {
    id: number;
    repoId: string;
    tenantRef: string;
    patchedFolder?: Omit<PatchedFolder, 'id'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

export interface DocumentsV1ReposFoldersRetrieveRequest {
    id: number;
    repoId: string;
    tenantRef: string;
}

export interface DocumentsV1ReposFoldersUpdateRequest {
    id: number;
    repoId: string;
    tenantRef: string;
    folder: Omit<Folder, 'id'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

export interface DocumentsV1ReposListRequest {
    tenantRef: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsV1ReposPartialUpdateRequest {
    id: number;
    tenantRef: string;
    patchedDocumentRepo?: Omit<PatchedDocumentRepo, 'id'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

export interface DocumentsV1ReposRetrieveRequest {
    id: number;
    tenantRef: string;
}

export interface DocumentsV1ReposUpdateRequest {
    id: number;
    tenantRef: string;
    documentRepo: Omit<DocumentRepo, 'id'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

export interface DocumentsV1TagsCreateRequest {
    tenantRef: string;
    tag: Omit<Tag, 'id'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

export interface DocumentsV1TagsDestroyRequest {
    id: number;
    tenantRef: string;
}

export interface DocumentsV1TagsListRequest {
    tenantRef: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsV1TagsPartialUpdateRequest {
    id: number;
    tenantRef: string;
    patchedTag?: Omit<PatchedTag, 'id'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

export interface DocumentsV1TagsRetrieveRequest {
    id: number;
    tenantRef: string;
}

export interface DocumentsV1TagsUpdateRequest {
    id: number;
    tenantRef: string;
    tag: Omit<Tag, 'id'|'created_at'|'updated_at'|'archive_at'|'tenant'|'created_by'|'updated_by'>;
}

/**
 * 
 */
export class DocumentsApi extends runtime.BaseAPI {

    /**
     * Add a new document repository to the system.
     * Create a new document repository
     */
    async documentsV1ReposCreateRaw(requestParameters: DocumentsV1ReposCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentRepo>> {
        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposCreate().'
            );
        }

        if (requestParameters['documentRepo'] == null) {
            throw new runtime.RequiredError(
                'documentRepo',
                'Required parameter "documentRepo" was null or undefined when calling documentsV1ReposCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/`;
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentRepoToJSON(requestParameters['documentRepo']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentRepoFromJSON(jsonValue));
    }

    /**
     * Add a new document repository to the system.
     * Create a new document repository
     */
    async documentsV1ReposCreate(requestParameters: DocumentsV1ReposCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentRepo> {
        const response = await this.documentsV1ReposCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a document repository from the system by its ID.
     * Delete a document repository
     */
    async documentsV1ReposDestroyRaw(requestParameters: DocumentsV1ReposDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDestroy().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a document repository from the system by its ID.
     * Delete a document repository
     */
    async documentsV1ReposDestroy(requestParameters: DocumentsV1ReposDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsV1ReposDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Add a new document to a specific document repository.
     * Create a new document in a document repository
     */
    async documentsV1ReposDocumentsCreateRaw(requestParameters: DocumentsV1ReposDocumentsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsCreate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsCreate().'
            );
        }

        if (requestParameters['document'] == null) {
            throw new runtime.RequiredError(
                'document',
                'Required parameter "document" was null or undefined when calling documentsV1ReposDocumentsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters['document']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Add a new document to a specific document repository.
     * Create a new document in a document repository
     */
    async documentsV1ReposDocumentsCreate(requestParameters: DocumentsV1ReposDocumentsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.documentsV1ReposDocumentsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a document from a specific document repository by its ID.
     * Delete a document in a document repository
     */
    async documentsV1ReposDocumentsDestroyRaw(requestParameters: DocumentsV1ReposDocumentsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsDestroy().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsDestroy().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a document from a specific document repository by its ID.
     * Delete a document in a document repository
     */
    async documentsV1ReposDocumentsDestroy(requestParameters: DocumentsV1ReposDocumentsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsV1ReposDocumentsDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a list of all documents within a specific document repository, optionally filtered by folder.
     * List all documents in a document repository
     */
    async documentsV1ReposDocumentsListRaw(requestParameters: DocumentsV1ReposDocumentsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedDocumentList>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsList().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['author'] != null) {
            queryParameters['author'] = requestParameters['author'];
        }

        if (requestParameters['folderId'] != null) {
            queryParameters['folder_id'] = requestParameters['folderId'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['production'] != null) {
            queryParameters['production'] = requestParameters['production'];
        }

        if (requestParameters['statusIexact'] != null) {
            queryParameters['status__iexact'] = requestParameters['statusIexact'];
        }

        if (requestParameters['titleIcontains'] != null) {
            queryParameters['title_icontains'] = requestParameters['titleIcontains'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedDocumentListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all documents within a specific document repository, optionally filtered by folder.
     * List all documents in a document repository
     */
    async documentsV1ReposDocumentsList(requestParameters: DocumentsV1ReposDocumentsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedDocumentList> {
        const response = await this.documentsV1ReposDocumentsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update specific fields of an existing document in a document repository without affecting others.
     * Partially update a document in a document repository
     */
    async documentsV1ReposDocumentsPartialUpdateRaw(requestParameters: DocumentsV1ReposDocumentsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsPartialUpdate().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsPartialUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedDocumentToJSON(requestParameters['patchedDocument']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Update specific fields of an existing document in a document repository without affecting others.
     * Partially update a document in a document repository
     */
    async documentsV1ReposDocumentsPartialUpdate(requestParameters: DocumentsV1ReposDocumentsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.documentsV1ReposDocumentsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get detailed information about a specific document in a document repository by its ID.
     * Retrieve a specific document in a document repository
     */
    async documentsV1ReposDocumentsRetrieveRaw(requestParameters: DocumentsV1ReposDocumentsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsRetrieve().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsRetrieve().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Get detailed information about a specific document in a document repository by its ID.
     * Retrieve a specific document in a document repository
     */
    async documentsV1ReposDocumentsRetrieve(requestParameters: DocumentsV1ReposDocumentsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.documentsV1ReposDocumentsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new tag to a specific document within a document repository.
     * Assign tag to a document
     */
    async documentsV1ReposDocumentsTagsCreateRaw(requestParameters: DocumentsV1ReposDocumentsTagsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTag>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsTagsCreate().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsTagsCreate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsTagsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/tags/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTagToJSON(requestParameters['documentTag']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTagFromJSON(jsonValue));
    }

    /**
     * Add a new tag to a specific document within a document repository.
     * Assign tag to a document
     */
    async documentsV1ReposDocumentsTagsCreate(requestParameters: DocumentsV1ReposDocumentsTagsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTag> {
        const response = await this.documentsV1ReposDocumentsTagsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a specific tag from a document by its ID.
     * Remove tag from a document
     */
    async documentsV1ReposDocumentsTagsDestroyRaw(requestParameters: DocumentsV1ReposDocumentsTagsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsTagsDestroy().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsTagsDestroy().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsTagsDestroy().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsTagsDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/tags/{id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a specific tag from a document by its ID.
     * Remove tag from a document
     */
    async documentsV1ReposDocumentsTagsDestroy(requestParameters: DocumentsV1ReposDocumentsTagsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsV1ReposDocumentsTagsDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a list of all tags associated with a specific document within a document repository.
     * List all tags for a document
     */
    async documentsV1ReposDocumentsTagsListRaw(requestParameters: DocumentsV1ReposDocumentsTagsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedDocumentTagList>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsTagsList().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsTagsList().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsTagsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/tags/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedDocumentTagListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all tags associated with a specific document within a document repository.
     * List all tags for a document
     */
    async documentsV1ReposDocumentsTagsList(requestParameters: DocumentsV1ReposDocumentsTagsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedDocumentTagList> {
        const response = await this.documentsV1ReposDocumentsTagsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get detailed information about a specific tag associated with a document by its ID.
     * Retrieve a specific tag for a document
     */
    async documentsV1ReposDocumentsTagsRetrieveRaw(requestParameters: DocumentsV1ReposDocumentsTagsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTag>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsTagsRetrieve().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsTagsRetrieve().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsTagsRetrieve().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsTagsRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/tags/{id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTagFromJSON(jsonValue));
    }

    /**
     * Get detailed information about a specific tag associated with a document by its ID.
     * Retrieve a specific tag for a document
     */
    async documentsV1ReposDocumentsTagsRetrieve(requestParameters: DocumentsV1ReposDocumentsTagsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTag> {
        const response = await this.documentsV1ReposDocumentsTagsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify the details of an existing document in a document repository by its ID.
     * Update an existing document in a document repository
     */
    async documentsV1ReposDocumentsUpdateRaw(requestParameters: DocumentsV1ReposDocumentsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsUpdate().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsUpdate().'
            );
        }

        if (requestParameters['document'] == null) {
            throw new runtime.RequiredError(
                'document',
                'Required parameter "document" was null or undefined when calling documentsV1ReposDocumentsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters['document']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Modify the details of an existing document in a document repository by its ID.
     * Update an existing document in a document repository
     */
    async documentsV1ReposDocumentsUpdate(requestParameters: DocumentsV1ReposDocumentsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.documentsV1ReposDocumentsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new version to a specific document within a document repository.
     * Create a new version of a document
     */
    async documentsV1ReposDocumentsVersionsCreateRaw(requestParameters: DocumentsV1ReposDocumentsVersionsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersion>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsVersionsCreate().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsVersionsCreate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsVersionsCreate().'
            );
        }

        if (requestParameters['documentVersion'] == null) {
            throw new runtime.RequiredError(
                'documentVersion',
                'Required parameter "documentVersion" was null or undefined when calling documentsV1ReposDocumentsVersionsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/versions/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionToJSON(requestParameters['documentVersion']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionFromJSON(jsonValue));
    }

    /**
     * Add a new version to a specific document within a document repository.
     * Create a new version of a document
     */
    async documentsV1ReposDocumentsVersionsCreate(requestParameters: DocumentsV1ReposDocumentsVersionsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersion> {
        const response = await this.documentsV1ReposDocumentsVersionsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a specific version of a document from the system by its ID.
     * Delete a version of a document
     */
    async documentsV1ReposDocumentsVersionsDestroyRaw(requestParameters: DocumentsV1ReposDocumentsVersionsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsVersionsDestroy().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsVersionsDestroy().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsVersionsDestroy().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsVersionsDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/versions/{id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a specific version of a document from the system by its ID.
     * Delete a version of a document
     */
    async documentsV1ReposDocumentsVersionsDestroy(requestParameters: DocumentsV1ReposDocumentsVersionsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsV1ReposDocumentsVersionsDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a list of all versions of a specific document within a document repository.
     * List all versions of a document
     */
    async documentsV1ReposDocumentsVersionsListRaw(requestParameters: DocumentsV1ReposDocumentsVersionsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedDocumentVersionList>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsVersionsList().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsVersionsList().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsVersionsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/versions/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedDocumentVersionListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all versions of a specific document within a document repository.
     * List all versions of a document
     */
    async documentsV1ReposDocumentsVersionsList(requestParameters: DocumentsV1ReposDocumentsVersionsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedDocumentVersionList> {
        const response = await this.documentsV1ReposDocumentsVersionsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update specific fields of an existing version of a document without affecting others.
     * Partially update a version of a document
     */
    async documentsV1ReposDocumentsVersionsPartialUpdateRaw(requestParameters: DocumentsV1ReposDocumentsVersionsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersion>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsVersionsPartialUpdate().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsVersionsPartialUpdate().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsVersionsPartialUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsVersionsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/versions/{id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedDocumentVersionToJSON(requestParameters['patchedDocumentVersion']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionFromJSON(jsonValue));
    }

    /**
     * Update specific fields of an existing version of a document without affecting others.
     * Partially update a version of a document
     */
    async documentsV1ReposDocumentsVersionsPartialUpdate(requestParameters: DocumentsV1ReposDocumentsVersionsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersion> {
        const response = await this.documentsV1ReposDocumentsVersionsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get detailed information about a specific version of a document by its ID.
     * Retrieve a specific version of a document
     */
    async documentsV1ReposDocumentsVersionsRetrieveRaw(requestParameters: DocumentsV1ReposDocumentsVersionsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersion>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsVersionsRetrieve().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsVersionsRetrieve().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsVersionsRetrieve().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsVersionsRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/versions/{id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionFromJSON(jsonValue));
    }

    /**
     * Get detailed information about a specific version of a document by its ID.
     * Retrieve a specific version of a document
     */
    async documentsV1ReposDocumentsVersionsRetrieve(requestParameters: DocumentsV1ReposDocumentsVersionsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersion> {
        const response = await this.documentsV1ReposDocumentsVersionsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify the details of an existing version of a document by its ID.
     * Update an existing version of a document
     */
    async documentsV1ReposDocumentsVersionsUpdateRaw(requestParameters: DocumentsV1ReposDocumentsVersionsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersion>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsV1ReposDocumentsVersionsUpdate().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposDocumentsVersionsUpdate().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposDocumentsVersionsUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposDocumentsVersionsUpdate().'
            );
        }

        if (requestParameters['documentVersion'] == null) {
            throw new runtime.RequiredError(
                'documentVersion',
                'Required parameter "documentVersion" was null or undefined when calling documentsV1ReposDocumentsVersionsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/documents/{document_id}/versions/{id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionToJSON(requestParameters['documentVersion']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionFromJSON(jsonValue));
    }

    /**
     * Modify the details of an existing version of a document by its ID.
     * Update an existing version of a document
     */
    async documentsV1ReposDocumentsVersionsUpdate(requestParameters: DocumentsV1ReposDocumentsVersionsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersion> {
        const response = await this.documentsV1ReposDocumentsVersionsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new folder to a specific document repository.
     * Create a new folder in a document repository
     */
    async documentsV1ReposFoldersCreateRaw(requestParameters: DocumentsV1ReposFoldersCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposFoldersCreate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposFoldersCreate().'
            );
        }

        if (requestParameters['folder'] == null) {
            throw new runtime.RequiredError(
                'folder',
                'Required parameter "folder" was null or undefined when calling documentsV1ReposFoldersCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/folders/`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FolderToJSON(requestParameters['folder']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Add a new folder to a specific document repository.
     * Create a new folder in a document repository
     */
    async documentsV1ReposFoldersCreate(requestParameters: DocumentsV1ReposFoldersCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.documentsV1ReposFoldersCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a folder from a specific document repository by its ID.
     * Delete a folder in a document repository
     */
    async documentsV1ReposFoldersDestroyRaw(requestParameters: DocumentsV1ReposFoldersDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposFoldersDestroy().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposFoldersDestroy().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposFoldersDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/folders/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a folder from a specific document repository by its ID.
     * Delete a folder in a document repository
     */
    async documentsV1ReposFoldersDestroy(requestParameters: DocumentsV1ReposFoldersDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsV1ReposFoldersDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a list of all folders within a specific document repository, optionally filtered by parent folder.
     * List all folders in a document repository
     */
    async documentsV1ReposFoldersListRaw(requestParameters: DocumentsV1ReposFoldersListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedFolderList>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposFoldersList().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposFoldersList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['parentFolderId'] != null) {
            queryParameters['parent_folder_id'] = requestParameters['parentFolderId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/folders/`;
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedFolderListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all folders within a specific document repository, optionally filtered by parent folder.
     * List all folders in a document repository
     */
    async documentsV1ReposFoldersList(requestParameters: DocumentsV1ReposFoldersListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedFolderList> {
        const response = await this.documentsV1ReposFoldersListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update specific fields of an existing folder in a document repository without affecting others.
     * Partially update a folder in a document repository
     */
    async documentsV1ReposFoldersPartialUpdateRaw(requestParameters: DocumentsV1ReposFoldersPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposFoldersPartialUpdate().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposFoldersPartialUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposFoldersPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/folders/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedFolderToJSON(requestParameters['patchedFolder']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Update specific fields of an existing folder in a document repository without affecting others.
     * Partially update a folder in a document repository
     */
    async documentsV1ReposFoldersPartialUpdate(requestParameters: DocumentsV1ReposFoldersPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.documentsV1ReposFoldersPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get detailed information about a specific folder in a document repository by its ID.
     * Retrieve a specific folder in a document repository
     */
    async documentsV1ReposFoldersRetrieveRaw(requestParameters: DocumentsV1ReposFoldersRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposFoldersRetrieve().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposFoldersRetrieve().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposFoldersRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/folders/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Get detailed information about a specific folder in a document repository by its ID.
     * Retrieve a specific folder in a document repository
     */
    async documentsV1ReposFoldersRetrieve(requestParameters: DocumentsV1ReposFoldersRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.documentsV1ReposFoldersRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify the details of an existing folder in a document repository by its ID.
     * Update an existing folder in a document repository
     */
    async documentsV1ReposFoldersUpdateRaw(requestParameters: DocumentsV1ReposFoldersUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposFoldersUpdate().'
            );
        }

        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling documentsV1ReposFoldersUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposFoldersUpdate().'
            );
        }

        if (requestParameters['folder'] == null) {
            throw new runtime.RequiredError(
                'folder',
                'Required parameter "folder" was null or undefined when calling documentsV1ReposFoldersUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{repo_id}/folders/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"repo_id"}}`, encodeURIComponent(String(requestParameters['repoId'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FolderToJSON(requestParameters['folder']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Modify the details of an existing folder in a document repository by its ID.
     * Update an existing folder in a document repository
     */
    async documentsV1ReposFoldersUpdate(requestParameters: DocumentsV1ReposFoldersUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.documentsV1ReposFoldersUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of all document repositories in the system.
     * List all document repositories
     */
    async documentsV1ReposListRaw(requestParameters: DocumentsV1ReposListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedDocumentRepoList>> {
        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/`;
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedDocumentRepoListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all document repositories in the system.
     * List all document repositories
     */
    async documentsV1ReposList(requestParameters: DocumentsV1ReposListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedDocumentRepoList> {
        const response = await this.documentsV1ReposListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update specific fields of an existing document repository without affecting others.
     * Partially update a document repository
     */
    async documentsV1ReposPartialUpdateRaw(requestParameters: DocumentsV1ReposPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentRepo>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposPartialUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedDocumentRepoToJSON(requestParameters['patchedDocumentRepo']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentRepoFromJSON(jsonValue));
    }

    /**
     * Update specific fields of an existing document repository without affecting others.
     * Partially update a document repository
     */
    async documentsV1ReposPartialUpdate(requestParameters: DocumentsV1ReposPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentRepo> {
        const response = await this.documentsV1ReposPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get detailed information about a specific document repository by its ID.
     * Retrieve a specific document repository
     */
    async documentsV1ReposRetrieveRaw(requestParameters: DocumentsV1ReposRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentRepo>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposRetrieve().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentRepoFromJSON(jsonValue));
    }

    /**
     * Get detailed information about a specific document repository by its ID.
     * Retrieve a specific document repository
     */
    async documentsV1ReposRetrieve(requestParameters: DocumentsV1ReposRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentRepo> {
        const response = await this.documentsV1ReposRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify the details of an existing document repository by its ID.
     * Update an existing document repository
     */
    async documentsV1ReposUpdateRaw(requestParameters: DocumentsV1ReposUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentRepo>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1ReposUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1ReposUpdate().'
            );
        }

        if (requestParameters['documentRepo'] == null) {
            throw new runtime.RequiredError(
                'documentRepo',
                'Required parameter "documentRepo" was null or undefined when calling documentsV1ReposUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/repos/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentRepoToJSON(requestParameters['documentRepo']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentRepoFromJSON(jsonValue));
    }

    /**
     * Modify the details of an existing document repository by its ID.
     * Update an existing document repository
     */
    async documentsV1ReposUpdate(requestParameters: DocumentsV1ReposUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentRepo> {
        const response = await this.documentsV1ReposUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new tag to the system.
     * Create a new tag
     */
    async documentsV1TagsCreateRaw(requestParameters: DocumentsV1TagsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Tag>> {
        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1TagsCreate().'
            );
        }

        if (requestParameters['tag'] == null) {
            throw new runtime.RequiredError(
                'tag',
                'Required parameter "tag" was null or undefined when calling documentsV1TagsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/tags/`;
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TagToJSON(requestParameters['tag']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagFromJSON(jsonValue));
    }

    /**
     * Add a new tag to the system.
     * Create a new tag
     */
    async documentsV1TagsCreate(requestParameters: DocumentsV1TagsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Tag> {
        const response = await this.documentsV1TagsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a tag from the system by its ID.
     * Delete a tag
     */
    async documentsV1TagsDestroyRaw(requestParameters: DocumentsV1TagsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1TagsDestroy().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1TagsDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/tags/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a tag from the system by its ID.
     * Delete a tag
     */
    async documentsV1TagsDestroy(requestParameters: DocumentsV1TagsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsV1TagsDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a list of all tags in the system.
     * List all tags
     */
    async documentsV1TagsListRaw(requestParameters: DocumentsV1TagsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedTagList>> {
        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1TagsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/tags/`;
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedTagListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all tags in the system.
     * List all tags
     */
    async documentsV1TagsList(requestParameters: DocumentsV1TagsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedTagList> {
        const response = await this.documentsV1TagsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update specific fields of an existing tag without affecting others.
     * Partially update a tag
     */
    async documentsV1TagsPartialUpdateRaw(requestParameters: DocumentsV1TagsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Tag>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1TagsPartialUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1TagsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/tags/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedTagToJSON(requestParameters['patchedTag']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagFromJSON(jsonValue));
    }

    /**
     * Update specific fields of an existing tag without affecting others.
     * Partially update a tag
     */
    async documentsV1TagsPartialUpdate(requestParameters: DocumentsV1TagsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Tag> {
        const response = await this.documentsV1TagsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get detailed information about a specific tag by its ID.
     * Retrieve a specific tag
     */
    async documentsV1TagsRetrieveRaw(requestParameters: DocumentsV1TagsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Tag>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1TagsRetrieve().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1TagsRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/t/{tenant_ref}/documents/v1/tags/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagFromJSON(jsonValue));
    }

    /**
     * Get detailed information about a specific tag by its ID.
     * Retrieve a specific tag
     */
    async documentsV1TagsRetrieve(requestParameters: DocumentsV1TagsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Tag> {
        const response = await this.documentsV1TagsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify the details of an existing tag by its ID.
     * Update an existing tag
     */
    async documentsV1TagsUpdateRaw(requestParameters: DocumentsV1TagsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Tag>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling documentsV1TagsUpdate().'
            );
        }

        if (requestParameters['tenantRef'] == null) {
            throw new runtime.RequiredError(
                'tenantRef',
                'Required parameter "tenantRef" was null or undefined when calling documentsV1TagsUpdate().'
            );
        }

        if (requestParameters['tag'] == null) {
            throw new runtime.RequiredError(
                'tag',
                'Required parameter "tag" was null or undefined when calling documentsV1TagsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/t/{tenant_ref}/documents/v1/tags/{id}/`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"tenant_ref"}}`, encodeURIComponent(String(requestParameters['tenantRef'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TagToJSON(requestParameters['tag']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagFromJSON(jsonValue));
    }

    /**
     * Modify the details of an existing tag by its ID.
     * Update an existing tag
     */
    async documentsV1TagsUpdate(requestParameters: DocumentsV1TagsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Tag> {
        const response = await this.documentsV1TagsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
